# Minecraft Resource Generator

This is a python module aimed to enable simple generation of the many json files that are required for forge modding.

Some examples from No Tree Punching 1.13 by AlcatrazEscapee:

```python
from mcresources import ResourceManager
rm = ResourceManager('notreepunching')

for stone in ['stone', 'sandstone', 'andesite', 'granite', 'diorite']:
    # Block States
    rm.blockstate(('loose_rock', stone))
    # Block Models
    rm.block_model(('loose_rock', stone), 'minecraft:block/%s' % stone, 'notreepunching:block/loose_rock')
    # Item Models
    rm.item_model(('rock', stone))
    # Crafting Recipes
    result = ('cobblestone' if stone == 'stone' else stone)
    rm.crafting_shaped('%s_from_rocks' % result, ['##', '##'], 'notreepunching:rock/%s' % stone, 'minecraft:%s' % result)

# Item Models
for tool in ['pickaxe', 'shovel', 'axe', 'hoe', 'knife']:
    rm.item_model('flint_%s' % tool, parent='item/handheld')
    
# Shaped Crafting
for metal in ['iron', 'gold', 'diamond']:
    tool_metal = 'tag!forge:' + ('gems' if metal == 'diamond' else 'ingots') + '/' + metal
    metal_prefix = metal if metal != 'gold' else 'golden'
    rm.crafting_shaped('%s_knife' % metal, ['I', 'S'], {'I': tool_metal, 'S': 'tag!forge:rods/wooden'}, 'notreepunching:%s_knife' % metal_prefix)

# More Crafting Recipes
rm.crafting_shapeless('plant_string', ['notreepunching:plant_fiber'] * 3, 'notreepunching:plant_string')
```

---
### Usage

mcresources can build many common files that are required for forge modding, and provide utilities to manage a larger project. The following is an outline of the various methods and how to use them in the most efficient manner.

All files generated by mcresources will have a comment (`'__comment__'`) inserted to identify them. This also allows mcresources via the usage of `clean_generated_resources()` to delete all files that have been generated, allowing the user to see which ones are created manually, and/or manage updating older files to a newer configuration

A few elements are common to multiple methods:
 - `name_parts`: This represents the resource location for a specific block or item. It can be specified as a string, i.e. `'block_ruby_ore'`, or as a list or tuple if the block uses directories as separators. This means that `('ore_blocks', 'ruby')` corresponds to the resource location `modid:ore_blocks/ruby`, and the resulting file `ruby.json` would be found in `modid/blockstates/ore_blocks/`

 - `conditions`: A single condition can either be specified as a fully specified dictionary (which will be inserted into the json verbatim), or as a string, which will be expanded to `{ 'type': string_condition }`
 
 - `item stacks`: An item stack can be specified as a fully specified dictionary (which will be inserted into the json verbatim), or as a string. As a string, it must represent an item resource location, i.e. `minecraft:golden_boots` will create the json `{ 'item': 'minecraft:golden_boots' }`. Additionally, you can prefix the string with `tag!` to specify that it represents a tag, i.e. `tag!forge:rods/wooden` will create the json `{ 'tag': 'forge:rods/wooden' }`

##### Blockstates
```python
def blockstate(self, name_parts: str or list or tuple, model: str = None, variants: dict = None)
```
 - `name_parts` specifies the block resource location, as seen above
 - `model` specifies the model. If not present, it will default to `modid:block/name/parts`, meaning `blockstate('pink_grass')` will create the file `modid/blockstates/pink_grass.json`, which has a model of `modid:block/pink_grass`
 - `variants` specifies the variants as found in the json file. It should be a dictionary as per usual minecraft blockstate files. If it isn't present, it will default to an empty / single variant block: `'variants': { '': model }`

##### Block Models
```python
def block_model(self, name_parts: str or list or tuple, textures: str or dict = None,
                    parent: str = 'cube_all')
```
 - `name_parts` specifies the block resource location, as seen above
 - `textures` specifies the textures for this specific model. If it is a string, it will create the json: `'textures': { 'texture': textures }`. If provided as a dictionary, it will insert `'textures': textures`
 - `parent` specifies the parent model file

##### Item Models
```python
def item_model(self, name_parts: str or list or tuple, *textures: str or dict, parent: str = 'item/generated')
```
 - `name_parts` specifies the item resource location, as seen above
 - `textures` specifies the textures. If textures are supplied as strings, i.e. `'base_layer', 'middle_layer' ...`, it will assign them sequentially to layers, i.e. `{ 'layer0': 'base_layer', 'layer1': 'middle_layer' ... }`. If a dictionary is provided, it will insert those in the same way as the block model
 - `parent` specifies the parent model file

##### Shapeless Crafting Recipes
```python
def crafting_shapeless(self, name_parts: str or list or tuple, ingredients: str or dict or list or tuple, result: str or dict, group: str = None, conditions: str or dict or list = None)
```
 - `name_parts` specifies the recipe resource location. Note crafting recipes are automatically added to `modid/data/recipes`
 - `inredients` specifies the ingredients. It must be either a list / tuple of item stacks, or a string or dictionary representing an item stack. See above for valid item stack specifications.
 - `result` specifies the recipe result or output. It must be a single item stack
 - `group` specifies the group the recipe belongs to
 - `conditions` specifies any conditions on the recipe being enabled. It must be a list / tuple of valid condition identifiers, or a string or dictionary representing an item stack

##### Shaped Crafting Recipes
```python
def crafting_shaped(self, name_parts: str or list or tuple, pattern: list, ingredients: str or dict, result, group: str = None, conditions: str or dict or list = None)
```
 - `name_parts` specifies the recipe resource location. Note crafting recipes are automatically added to `modid/data/recipes`
 - `pattern` specifies the pattern. It must be a list of strings, i.e. `['XXX', ' S ', ' S ']` for a pickaxe pattern. The keys must be the same as used in the ingredients field.
 - `inredients` specifies the ingredients. It can be a dictionary of single character keys to item stacks, or it can be a single item stack (which will default to the first key found, and as such should only be used if there is only one unique input)
 - `result` specifies the recipe result or output. It must be a single item stack
 - `group` is as above
 - `conditions` is as above

##### Other Recipes
```python
def recipe(self, name_parts: str or list or tuple, type_in: str, data_in: dict, group: str = None, conditions: str or dict or list = None)
```
This is used to create modded recipes that are loaded via custom deserializers. As such, `name_parts` needs to include a subdirectory for the recipe type
 - `name_parts` specifies the recipe resource location.
 - `type_in` specifies the recipe type
 - `data_in` specifies the json data to be inserted into the recipe
 - `group` is as above
 - `conditions` is as above

##### Tags
```python
def item_tag(self, name_parts: str or list or tuple, *values: str or list or tuple, replace: bool = False)
def block_tag(self, name_parts: str or list or tuple, *values: str or list, replace: bool = False)
```
These are used to create item and block tags respectively
 - `name_parts` specifies the tag resource location, as seen above
 - `values` specifies the values. It can be a single string for one value, or a list / tuple of strings for multiple values
 - `replace` specifies the replace field in the json, i.e. if the tag should replace a previous identical entry

